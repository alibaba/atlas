/*
 *
 *                                Apache License
 *                          Version 2.0, January 2004
 *                       http://www.apache.org/licenses/
 *
 *  TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *  1. Definitions.
 *
 *     "License" shall mean the terms and conditions for use, reproduction,
 *     and distribution as defined by Sections 1 through 9 of this document.
 *
 *     "Licensor" shall mean the copyright owner or entity authorized by
 *     the copyright owner that is granting the License.
 *
 *     "Legal Entity" shall mean the union of the acting entity and all
 *     other entities that control, are controlled by, or are under common
 *     control with that entity. For the purposes of this definition,
 *     "control" means (i) the power, direct or indirect, to cause the
 *     direction or management of such entity, whether by contract or
 *     otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *     outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *     "You" (or "Your") shall mean an individual or Legal Entity
 *     exercising permissions granted by this License.
 *
 *     "Source" form shall mean the preferred form for making modifications,
 *     including but not limited to software source code, documentation
 *     source, and configuration files.
 *
 *     "Object" form shall mean any form resulting from mechanical
 *     transformation or translation of a Source form, including but
 *     not limited to compiled object code, generated documentation,
 *     and conversions to other media types.
 *
 *     "Work" shall mean the work of authorship, whether in Source or
 *     Object form, made available under the License, as indicated by a
 *     copyright notice that is included in or attached to the work
 *     (an example is provided in the Appendix below).
 *
 *     "Derivative Works" shall mean any work, whether in Source or Object
 *     form, that is based on (or derived from) the Work and for which the
 *     editorial revisions, annotations, elaborations, or other modifications
 *     represent, as a whole, an original work of authorship. For the purposes
 *     of this License, Derivative Works shall not include works that remain
 *     separable from, or merely link (or bind by name) to the interfaces of,
 *     the Work and Derivative Works thereof.
 *
 *     "Contribution" shall mean any work of authorship, including
 *     the original version of the Work and any modifications or additions
 *     to that Work or Derivative Works thereof, that is intentionally
 *     submitted to Licensor for inclusion in the Work by the copyright owner
 *     or by an individual or Legal Entity authorized to submit on behalf of
 *     the copyright owner. For the purposes of this definition, "submitted"
 *     means any form of electronic, verbal, or written communication sent
 *     to the Licensor or its representatives, including but not limited to
 *     communication on electronic mailing lists, source code control systems,
 *     and issue tracking systems that are managed by, or on behalf of, the
 *     Licensor for the purpose of discussing and improving the Work, but
 *     excluding communication that is conspicuously marked or otherwise
 *     designated in writing by the copyright owner as "Not a Contribution."
 *
 *     "Contributor" shall mean Licensor and any individual or Legal Entity
 *     on behalf of whom a Contribution has been received by Licensor and
 *     subsequently incorporated within the Work.
 *
 *  2. Grant of Copyright License. Subject to the terms and conditions of
 *     this License, each Contributor hereby grants to You a perpetual,
 *     worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *     copyright license to reproduce, prepare Derivative Works of,
 *     publicly display, publicly perform, sublicense, and distribute the
 *     Work and such Derivative Works in Source or Object form.
 *
 *  3. Grant of Patent License. Subject to the terms and conditions of
 *     this License, each Contributor hereby grants to You a perpetual,
 *     worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *     (except as stated in this section) patent license to make, have made,
 *     use, offer to sell, sell, import, and otherwise transfer the Work,
 *     where such license applies only to those patent claims licensable
 *     by such Contributor that are necessarily infringed by their
 *     Contribution(s) alone or by combination of their Contribution(s)
 *     with the Work to which such Contribution(s) was submitted. If You
 *     institute patent litigation against any entity (including a
 *     cross-claim or counterclaim in a lawsuit) alleging that the Work
 *     or a Contribution incorporated within the Work constitutes direct
 *     or contributory patent infringement, then any patent licenses
 *     granted to You under this License for that Work shall terminate
 *     as of the date such litigation is filed.
 *
 *  4. Redistribution. You may reproduce and distribute copies of the
 *     Work or Derivative Works thereof in any medium, with or without
 *     modifications, and in Source or Object form, provided that You
 *     meet the following conditions:
 *
 *     (a) You must give any other recipients of the Work or
 *         Derivative Works a copy of this License; and
 *
 *     (b) You must cause any modified files to carry prominent notices
 *         stating that You changed the files; and
 *
 *     (c) You must retain, in the Source form of any Derivative Works
 *         that You distribute, all copyright, patent, trademark, and
 *         attribution notices from the Source form of the Work,
 *         excluding those notices that do not pertain to any part of
 *         the Derivative Works; and
 *
 *     (d) If the Work includes a "NOTICE" text file as part of its
 *         distribution, then any Derivative Works that You distribute must
 *         include a readable copy of the attribution notices contained
 *         within such NOTICE file, excluding those notices that do not
 *         pertain to any part of the Derivative Works, in at least one
 *         of the following places: within a NOTICE text file distributed
 *         as part of the Derivative Works; within the Source form or
 *         documentation, if provided along with the Derivative Works; or,
 *         within a display generated by the Derivative Works, if and
 *         wherever such third-party notices normally appear. The contents
 *         of the NOTICE file are for informational purposes only and
 *         do not modify the License. You may add Your own attribution
 *         notices within Derivative Works that You distribute, alongside
 *         or as an addendum to the NOTICE text from the Work, provided
 *         that such additional attribution notices cannot be construed
 *         as modifying the License.
 *
 *     You may add Your own copyright statement to Your modifications and
 *     may provide additional or different license terms and conditions
 *     for use, reproduction, or distribution of Your modifications, or
 *     for any such Derivative Works as a whole, provided Your use,
 *     reproduction, and distribution of the Work otherwise complies with
 *     the conditions stated in this License.
 *
 *  5. Submission of Contributions. Unless You explicitly state otherwise,
 *     any Contribution intentionally submitted for inclusion in the Work
 *     by You to the Licensor shall be under the terms and conditions of
 *     this License, without any additional terms or conditions.
 *     Notwithstanding the above, nothing herein shall supersede or modify
 *     the terms of any separate license agreement you may have executed
 *     with Licensor regarding such Contributions.
 *
 *  6. Trademarks. This License does not grant permission to use the trade
 *     names, trademarks, service marks, or product names of the Licensor,
 *     except as required for reasonable and customary use in describing the
 *     origin of the Work and reproducing the content of the NOTICE file.
 *
 *  7. Disclaimer of Warranty. Unless required by applicable law or
 *     agreed to in writing, Licensor provides the Work (and each
 *     Contributor provides its Contributions) on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *     implied, including, without limitation, any warranties or conditions
 *     of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *     PARTICULAR PURPOSE. You are solely responsible for determining the
 *     appropriateness of using or redistributing the Work and assume any
 *     risks associated with Your exercise of permissions under this License.
 *
 *  8. Limitation of Liability. In no event and under no legal theory,
 *     whether in tort (including negligence), contract, or otherwise,
 *     unless required by applicable law (such as deliberate and grossly
 *     negligent acts) or agreed to in writing, shall any Contributor be
 *     liable to You for damages, including any direct, indirect, special,
 *     incidental, or consequential damages of any character arising as a
 *     result of this License or out of the use or inability to use the
 *     Work (including but not limited to damages for loss of goodwill,
 *     work stoppage, computer failure or malfunction, or any and all
 *     other commercial damages or losses), even if such Contributor
 *     has been advised of the possibility of such damages.
 *
 *  9. Accepting Warranty or Additional Liability. While redistributing
 *     the Work or Derivative Works thereof, You may choose to offer,
 *     and charge a fee for, acceptance of support, warranty, indemnity,
 *     or other liability obligations and/or rights consistent with this
 *     License. However, in accepting such obligations, You may act only
 *     on Your own behalf and on Your sole responsibility, not on behalf
 *     of any other Contributor, and only if You agree to indemnify,
 *     defend, and hold each Contributor harmless for any liability
 *     incurred by, or claims asserted against, such Contributor by reason
 *     of your accepting any such warranty or additional liability.
 *
 *  END OF TERMS AND CONDITIONS
 *
 *  APPENDIX: How to apply the Apache License to your work.
 *
 *     To apply the Apache License to your work, attach the following
 *     boilerplate notice, with the fields enclosed by brackets "[]"
 *     replaced with your own identifying information. (Don't include
 *     the brackets!)  The text should be enclosed in the appropriate
 *     comment syntax for the file format. We also recommend that a
 *     file or class name and description of purpose be included on the
 *     same "printed page" as the copyright notice for easier
 *     identification within third-party archives.
 *
 *  Copyright 2016 Alibaba Group
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *
 *
 */

package android.taobao.atlas.hack;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import android.app.Application;
import android.app.IActivityManager;
import android.app.Instrumentation;
import android.content.Context;
import android.content.ContextWrapper;
import android.content.pm.ApplicationInfo;
import android.content.pm.ProviderInfo;
import android.content.res.Resources;
import android.content.res.Resources.Theme;
import android.os.Build;
import android.os.IBinder;
import android.taobao.atlas.hack.Hack.AssertionFailureHandler;
import android.taobao.atlas.hack.Hack.HackDeclaration;
import android.taobao.atlas.hack.Hack.HackedClass;
import android.taobao.atlas.hack.Hack.HackedField;
import android.taobao.atlas.hack.Hack.HackedMethod;
import android.view.ContextThemeWrapper;

public class AtlasHacks extends HackDeclaration implements AssertionFailureHandler {

    public static boolean                                       sIsReflectAvailable     = false;
    public static boolean                                       sIsReflectChecked       = false;
    public static boolean                                       sIsIgnoreFailure        = false;

    private AssertionArrayException                             mExceptionArray         = null;

    // Classes
    public static HackedClass<Object>                           LoadedApk;
    public static HackedClass<Object>                           ActivityThread;
    public static HackedClass<android.content.res.Resources>    Resources;
    public static HackedClass<android.app.Application>          Application;
    public static HackedClass<android.content.res.AssetManager> AssetManager;
    public static HackedClass<Object>                           IPackageManager;
    public static HackedClass<android.app.Service>              Service;
    public static HackedClass<Object>                           ContextImpl;
    public static HackedClass<ContextThemeWrapper>              ContextThemeWrapper;
    public static HackedClass<android.content.ContextWrapper>   ContextWrapper;
    public static HackedClass<java.lang.ClassLoader>            ClassLoader;
    public static HackedClass<dalvik.system.DexClassLoader>     DexClassLoader;
    public static HackedClass<Object>                           LexFile;
    public static HackedClass<Object>                           PackageParser$Component;
    public static HackedClass<Object>                           PackageParser$Activity;
    public static HackedClass<Object>                           PackageParser$Service;
    public static HackedClass<Object>                           PackageParser$Provider;
    public static HackedClass<Object>                           PackageParser;
    public static HackedClass<Object>                           PackageParser$Package;
    public static HackedClass<Object>                           PackageParser$ActivityIntentInfo;
    public static HackedClass<Object>                           PackageParser$ServiceIntentInfo;
    public static HackedClass<Object>                           PackageParser$ProviderIntentInfo;
    public static HackedClass<Object>                           ActivityManagerNative;
    public static HackedClass<Object>                                                       Singleton;
    public static HackedClass<Object>                           ActivityThread$AppBindData;
    public static HackedClass<Object>                           ActivityManager;
    public static HackedClass<Object>                           StringBlock;

    // Fields
    public static HackedField<Object, Instrumentation>          ActivityThread_mInstrumentation;
    public static HackedField<Object, Application>          ActivityThread_mInitialApplication;    
    public static HackedField<Object, ArrayList<Application>>   ActivityThread_mAllApplications;
    public static HackedField<Object, Map<String, Object>>      ActivityThread_mPackages;
    public static HackedField<Object, Object>                   ActivityThread_sPackageManager;
    public static HackedField<Object, Application>              LoadedApk_mApplication;
    public static HackedField<Object, Resources>                LoadedApk_mResources;
    public static HackedField<Object, String>                   LoadedApk_mResDir;
    public static HackedField<Object, ClassLoader>              LoadedApk_mClassLoader;
    public static HackedField<Object, ClassLoader>              LoadedApk_mBaseClassLoader;
    public static HackedField<Object, String>                   LoadedApk_mAppDir;
    public static HackedField<Object, Resources>                ContextImpl_mResources;
    public static HackedField<Object, Theme>                    ContextImpl_mTheme;
    public static HackedField<ContextThemeWrapper, Context>     ContextThemeWrapper_mBase;
    public static HackedField<ContextThemeWrapper, Theme>       ContextThemeWrapper_mTheme;
    public static HackedField<ContextThemeWrapper, Resources>   ContextThemeWrapper_mResources;
    public static HackedField<ContextWrapper, Context>          ContextWrapper_mBase;
    public static HackedField<Object, ArrayList<Object>>        PackageParser$Component_intents;
    public static HackedField<Object, String>                   PackageParser$Package_packageName;
    public static HackedField<Object, ArrayList<Object>>                                    PackageParser$Package_activities;
    public static HackedField<Object, ArrayList<Object>>                                    PackageParser$Package_services;
    public static HackedField<Object, ArrayList<Object>>                                    PackageParser$Package_receivers;
    public static HackedField<Object, ArrayList<Object>>                                    PackageParser$Package_providers;
    public static HackedField<Object, ApplicationInfo>                                      PackageParser$Package_applicationInfo;
    public static HackedField<Object,Object>          PackageParser$ActivityIntentInfo_activity;
    public static HackedField<Object,Object>          PackageParser$ServiceIntentInfo_service;
    public static HackedField<Object,Object>          PackageParser$ProviderIntentInfo_provider;
    public static HackedField<Object,ProviderInfo>          PackageParser$Provider_info;
    public static HackedField<Object,Object>          ActivityManagerNative_gDefault;
    public static HackedField<Object, Object>         Singleton_mInstance;
    public static HackedField<Object,List<ProviderInfo>>      ActivityThread$AppBindData_providers;
    public static HackedField<Object,Object>  ActivityThread_mBoundApplication;
    public static HackedField<Object,Object>  ContextImpl_mPackageInfo;
    public static HackedField<Object,Object>                                  ActivityManager_IActivityManagerSingleton;



    // Methods
    public static HackedMethod                                  ActivityThread_currentActivityThread;
    public static HackedMethod                                  AssetManager_addAssetPath;
    public static HackedMethod                                  AssetManager_addAssetPathAsSharedLibrary;
    public static HackedField<android.content.res.AssetManager,Object>                    AssetManager_mStringBlocks;
    public static HackedMethod                                  Application_attach;
    public static HackedMethod                                  ClassLoader_findLibrary;
    public static HackedMethod                                  DexClassLoader_findClass;
    public static HackedMethod                                  PackageParser$Component_getComponentName;
    public static HackedMethod                                  LexFile_loadLex;
    public static HackedMethod                                  LexFile_loadClass;
    public static HackedMethod                                  LexFile_close;
    public static HackedMethod                                  PackageParser_parsePackage;
    public static HackedMethod                                  PackageParser_generatePackageInfo;
    public static HackedMethod                                  AssetManager_getResourceIdentifier;
    public static HackedMethod                                  AssetManager_ensureStringBlocks;
    public static HackedMethod                                  ContextImpl_setOuterContext;
    public static HackedMethod                                  Service_attach;
    public static HackedMethod                                  ActivityThread_installContentProviders;
    public static HackedMethod                                  ActivityThread_installProvider;
    public static HackedMethod                                  AssetManager_addAssetPathNative;
    public static HackedMethod                                  AssetManager_addAssetPathNative24;
    public static HackedMethod                                  AssetManager_addAssetPathNativeSamSung;
    public static HackedMethod                                  AssetManager_getStringBlockCount;
    public static HackedMethod                                  AssetManager_getNativeStringBlock;



    // Constructor
    public static Hack.HackedConstructor                        PackageParser_constructor;
    public static Hack.HackedConstructor                        StringBlock_constructor;

    // Match method
    public static ArrayList<HackedMethod>                       GeneratePackageInfoList = new ArrayList<HackedMethod>();
    public static ArrayList<HackedMethod>                       GetPackageInfoList      = new ArrayList<HackedMethod>();

    public static boolean defineAndVerify(){
        if (sIsReflectChecked) return sIsReflectAvailable;
        AtlasHacks atlasHacks = new AtlasHacks();
        try {
            Hack.setAssertionFailureHandler(atlasHacks);
            if (Build.VERSION.SDK_INT == 11) {
                atlasHacks.onAssertionFailure(new HackAssertionException("Hack Assertion Failed: Android OS Version 11"));
            }
            allClasses();
            allConstructors();
            allFields();
            allMethods();
            // 校验完成
            if (atlasHacks.mExceptionArray != null) {
                // 校验存在失败
                sIsReflectAvailable = false;
            } else {
                // 校验成功
                sIsReflectAvailable = true;
            }
        } catch (HackAssertionException e) {
            sIsReflectAvailable = false;
            e.printStackTrace();
        } finally {
            Hack.setAssertionFailureHandler(null);
            sIsReflectChecked = true;
        }
        return sIsReflectAvailable;
    }

    // Must init at first
    public static void allClasses() throws HackAssertionException {
        if (android.os.Build.VERSION.SDK_INT <= 8) {
            LoadedApk = Hack.into("android.app.ActivityThread$PackageInfo");
        } else {
            LoadedApk = Hack.into("android.app.LoadedApk");
        }
        ActivityThread = Hack.into("android.app.ActivityThread");
        Resources = Hack.into(Resources.class);
        Application = Hack.into(Application.class);
        AssetManager = Hack.into(android.content.res.AssetManager.class);
        IPackageManager = Hack.into("android.content.pm.IPackageManager");
        Service = Hack.into(android.app.Service.class);
        ContextImpl = Hack.into("android.app.ContextImpl");
        ContextThemeWrapper = Hack.into(ContextThemeWrapper.class);
        ContextWrapper = Hack.into("android.content.ContextWrapper");
        sIsIgnoreFailure = true;
        ClassLoader = Hack.into(java.lang.ClassLoader.class);
        DexClassLoader = Hack.into(dalvik.system.DexClassLoader.class);
        LexFile = Hack.into("dalvik.system.LexFile");
        PackageParser$Component = Hack.into("android.content.pm.PackageParser$Component");
        PackageParser$Activity = Hack.into("android.content.pm.PackageParser$Activity");
        PackageParser$Service = Hack.into("android.content.pm.PackageParser$Service");
        PackageParser$Provider = Hack.into("android.content.pm.PackageParser$Provider");

        PackageParser = Hack.into("android.content.pm.PackageParser");
        PackageParser$Package = Hack.into("android.content.pm.PackageParser$Package");
        PackageParser$ActivityIntentInfo = Hack.into("android.content.pm.PackageParser$ActivityIntentInfo");
        PackageParser$ServiceIntentInfo = Hack.into("android.content.pm.PackageParser$ServiceIntentInfo");
        PackageParser$ProviderIntentInfo = Hack.into("android.content.pm.PackageParser$ProviderIntentInfo");

        ActivityManagerNative = Hack.into("android.app.ActivityManagerNative");
        Singleton = Hack.into("android.util.Singleton");
        ActivityThread$AppBindData = Hack.into("android.app.ActivityThread$AppBindData");
        ActivityManager = Hack.into("android.app.ActivityManager");
        StringBlock=Hack.into("android.content.res.StringBlock");
        sIsIgnoreFailure = false;
    }

    public static void allFields() throws HackAssertionException {
        ActivityThread_mInstrumentation = ActivityThread.field("mInstrumentation").ofType(Instrumentation.class);
        ActivityThread_mAllApplications = ActivityThread.field("mAllApplications").ofGenericType(ArrayList.class);
        ActivityThread_mInitialApplication =  ActivityThread.field("mInitialApplication").ofType(Application.class);       
        ActivityThread_mPackages = ActivityThread.field("mPackages").ofGenericType(Map.class);
        ActivityThread_sPackageManager = ActivityThread.staticField("sPackageManager").ofType(IPackageManager.getmClass());

        LoadedApk_mApplication = LoadedApk.field("mApplication").ofType(Application.class);
        LoadedApk_mResources = LoadedApk.field("mResources").ofType(Resources.class);
        LoadedApk_mResDir = LoadedApk.field("mResDir").ofType(String.class);
        LoadedApk_mClassLoader = LoadedApk.field("mClassLoader").ofType(ClassLoader.class);
        LoadedApk_mBaseClassLoader = LoadedApk.field("mBaseClassLoader").ofType(ClassLoader.class);
        LoadedApk_mAppDir = LoadedApk.field("mAppDir").ofType(String.class);

        ContextImpl_mResources = ContextImpl.field("mResources").ofType(Resources.class);
        ContextImpl_mTheme = ContextImpl.field("mTheme").ofType(Theme.class);
        sIsIgnoreFailure = true;
        //not exists on android L
        ContextThemeWrapper_mBase = ContextThemeWrapper.field("mBase").ofType(Context.class);
        sIsIgnoreFailure = false;
        ContextThemeWrapper_mTheme = ContextThemeWrapper.field("mTheme").ofType(Theme.class);
        try {
            if (android.os.Build.VERSION.SDK_INT >= 17
                && ContextThemeWrapper.getmClass().getDeclaredField("mResources") != null) {
                ContextThemeWrapper_mResources = ContextThemeWrapper.field("mResources").ofType(Resources.class);
            }
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }

        ContextWrapper_mBase = ContextWrapper.field("mBase").ofType(Context.class);
//        Resources_mAssets = Resources.field("mAssets");
        PackageParser$Component_intents = PackageParser$Component.field("intents").ofGenericType(ArrayList.class);
        PackageParser$Package_activities = PackageParser$Package.field("activities").ofGenericType(ArrayList.class);
        PackageParser$Package_services = PackageParser$Package.field("services").ofGenericType(ArrayList.class);
        PackageParser$Package_receivers = PackageParser$Package.field("receivers").ofGenericType(ArrayList.class);
        PackageParser$Package_providers = PackageParser$Package.field("providers").ofGenericType(ArrayList.class);
        PackageParser$Package_applicationInfo = PackageParser$Package.field("applicationInfo").ofType(ApplicationInfo.class);
        PackageParser$Package_packageName = PackageParser$Package.field("packageName").ofGenericType(String.class);
        PackageParser$ActivityIntentInfo_activity = PackageParser$ActivityIntentInfo.field("activity").ofType(PackageParser$Activity.getmClass());
        PackageParser$ServiceIntentInfo_service = PackageParser$ServiceIntentInfo.field("service").ofType(PackageParser$Service.getmClass());
        PackageParser$ProviderIntentInfo_provider = PackageParser$ProviderIntentInfo.field("provider").ofType(PackageParser$Provider.getmClass());
        PackageParser$Provider_info = PackageParser$Provider.field("info").ofType(ProviderInfo.class);
        if(Build.VERSION.SDK_INT>25 || (Build.VERSION.SDK_INT==25 && Build.VERSION.PREVIEW_SDK_INT>0)) {
            ActivityManager_IActivityManagerSingleton = ActivityManager.staticField("IActivityManagerSingleton");
        }else{
            ActivityManagerNative_gDefault = ActivityManagerNative.staticField("gDefault");
        }
        Singleton_mInstance = Singleton.field("mInstance");
        ActivityThread$AppBindData_providers = ActivityThread$AppBindData.field("providers").ofGenericType(List.class);
        ActivityThread_mBoundApplication = ActivityThread.field("mBoundApplication");
        ContextImpl_mPackageInfo = ContextImpl.field("mPackageInfo");
        AssetManager_mStringBlocks = AssetManager.field("mStringBlocks");
    }

    public static void allMethods() throws HackAssertionException {

        ActivityThread_currentActivityThread = ActivityThread.method("currentActivityThread");
        AssetManager_addAssetPath = AssetManager.method("addAssetPath", String.class);
        if(Build.VERSION.SDK_INT>=24) {
            AssetManager_addAssetPathAsSharedLibrary = AssetManager.method("addAssetPathAsSharedLibrary", String.class);
        }
        Application_attach = Application.method("attach", Context.class);
        PackageParser$Component_getComponentName = PackageParser$Component.method("getComponentName");
        ClassLoader_findLibrary = ClassLoader.method("findLibrary", String.class);
        ContextImpl_setOuterContext = ContextImpl.method("setOuterContext",Context.class);

        if (LexFile != null && LexFile.getmClass() !=null ) {
            LexFile_loadLex = LexFile.method("loadLex", String.class, int.class);
            LexFile_loadClass = LexFile.method("loadClass", String.class, java.lang.ClassLoader.class);
            LexFile_close = LexFile.method("close");
            DexClassLoader_findClass = DexClassLoader.method("findClass", String.class);
        }

        try {
            if (Build.VERSION.SDK_INT>20){
                AssetManager_getResourceIdentifier = AssetManager.method("getResourceIdentifier", String.class, String.class, String.class);
                AssetManager_ensureStringBlocks = AssetManager.method("ensureStringBlocks");
            }
        } catch (Throwable e) {
        }

        ActivityThread_installContentProviders = ActivityThread.method("installContentProviders",Context.class,List.class);
        if(Build.VERSION.SDK_INT>25 || (Build.VERSION.SDK_INT==25 && Build.VERSION.PREVIEW_SDK_INT>0)) {
            ActivityThread_installProvider = ActivityThread.method("installProvider", Context.class, android.app.ContentProviderHolder.class,
                    ProviderInfo.class, boolean.class, boolean.class, boolean.class);
        }else if(Build.VERSION.SDK_INT==14){
            ActivityThread_installProvider = ActivityThread.method("installProvider", Context.class, android.app.ContentProviderHolder.class,
                    ProviderInfo.class, boolean.class);
        }else if(Build.VERSION.SDK_INT==15){
            ActivityThread_installProvider = ActivityThread.method("installProvider", Context.class, android.app.ContentProviderHolder.class,
                    ProviderInfo.class, boolean.class,boolean.class);
        }else{
            ActivityThread_installProvider = ActivityThread.method("installProvider", Context.class, IActivityManager.ContentProviderHolder.class,
                    ProviderInfo.class, boolean.class, boolean.class, boolean.class);
        }
        Service_attach = Service.method("attach",Context.class,ActivityThread.getmClass(),String.class,IBinder.class,Application.getmClass(),Object.class);

        AssetManager_addAssetPathNative = AssetManager.method("addAssetPathNative", String.class);
        if(AssetManager_addAssetPathNative==null || AssetManager_addAssetPathNative.getMethod()==null) {
            AssetManager_addAssetPathNative24 = AssetManager.method("addAssetPathNative", String.class, boolean.class);
        }
        if((AssetManager_addAssetPathNative==null || AssetManager_addAssetPathNative.getMethod()==null) &&
                (AssetManager_addAssetPathNative24==null || AssetManager_addAssetPathNative24.getMethod()==null)){
            AssetManager_addAssetPathNativeSamSung = AssetManager.method("addAssetPathNative", String.class, int.class);
        }
        AssetManager_getStringBlockCount=AssetManager.method("getStringBlockCount");
        AssetManager_getNativeStringBlock = AssetManager.method("getNativeStringBlock",int.class);

    }

    public static void allConstructors() throws HackAssertionException {
        if(Build.VERSION.SDK_INT<=20) {
            PackageParser_constructor = PackageParser.constructor(String.class);
        }else{
            PackageParser_constructor = PackageParser.constructor();
        }
        if(Build.VERSION.SDK_INT>=21) {
            StringBlock_constructor = StringBlock.constructor(long.class, boolean.class);
        }else {
            StringBlock_constructor = StringBlock.constructor(int.class, boolean.class);
        }
    }

    @Override
    public boolean onAssertionFailure(HackAssertionException failure) {
        if (sIsIgnoreFailure) return true;
        if (mExceptionArray == null) {
            mExceptionArray = new AssertionArrayException("atlas hack assert failed");
        }
        mExceptionArray.addException(failure);
        return true;
    }

}
